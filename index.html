<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç²’å­äº¤äº’</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { position: absolute; top: 10px; right: 10px; width: 180px; height: 135px; z-index: 2; transform: scaleX(-1); border: 1px solid #444; border-radius: 6px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; z-index: 10; }
        #ui-hint { position: absolute; bottom: 20px; left: 20px; color: #fff; z-index: 2; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 5px; border-left: 4px solid #fff; }
    </style>
</head>
<body>

    <div id="loading">æ¨¡å‹åŠ è½½ä¸­...</div>
    <div id="canvas-container"></div>
    <video id="video-element" playsinline></video>
    
    <div id="ui-hint">
        <div style="font-weight: bold; margin-bottom: 5px;">å•æ‰‹äº¤äº’æ¨¡å¼:</div>
        <div>â˜ï¸ 1 : ä½ å¥½ï¼Œé™Œç”Ÿäºº</div>
        <div>âœŒï¸ 2 : 2026æ–°å¹´å¿«ä¹</div>
        <div>ğŸ¤Ÿ 3 : AE Studio åˆ¶ä½œ</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        let scene, camera, renderer, particlesMesh;
        let targetPositions = [];
        const maxParticles = 8000;
        let currentText = "";
        let currentGesture = 1;

        // --- 1. Three.js åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 130;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(maxParticles * 3);
            const colors = new Float32Array(maxParticles * 3);
            
            // éšæœºåˆå§‹åŒ–ä½ç½®
            for(let i=0; i<maxParticles * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 500;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);

            updateText("ä½ å¥½ï¼Œé™Œç”Ÿäºº");
            animate();
        }

        // --- 2. æ–‡å­—é‡‡æ ·é€»è¾‘ ---
        function updateText(text) {
            if (currentText === text) return;
            currentText = text;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; canvas.height = 200;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 800, 200);
            ctx.font = 'bold 80px "Microsoft YaHei"';
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 400, 100);

            const data = ctx.getImageData(0, 0, 800, 200).data;
            const newCoords = [];
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 800; x += 2) {
                    if (data[(y * 800 + x) * 4] > 128) {
                        newCoords.push({ x: (x - 400) * 0.45, y: -(y - 100) * 0.45, z: 0 });
                    }
                }
            }
            targetPositions = newCoords;

            // ç»Ÿä¸€é¢œè‰²æ›´æ–°
            const colors = particlesMesh.geometry.attributes.color.array;
            const color = new THREE.Color(0x00ffff); // è®¾å®šä¸ºé’è‰²
            for(let i=0; i<maxParticles; i++) {
                const i3 = i * 3;
                if(i < targetPositions.length) {
                    colors[i3] = color.r; colors[i3+1] = color.g; colors[i3+2] = color.b;
                } else {
                    colors[i3] = 0; colors[i3+1] = 0; colors[i3+2] = 0;
                }
            }
            particlesMesh.geometry.attributes.color.needsUpdate = true;
        }

        // --- 3. æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (ä»…æ•°å­—) ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // æŒ‡å°–æ£€æµ‹é€»è¾‘
                const isIndex = hand[8].y < hand[6].y;
                const isMiddle = hand[12].y < hand[10].y;
                const isRing = hand[16].y < hand[14].y;

                let gid = currentGesture;
                if (isIndex && isMiddle && isRing) gid = 3;
                else if (isIndex && isMiddle) gid = 2;
                else if (isIndex) gid = 1;

                if (gid !== currentGesture) {
                    currentGesture = gid;
                    const map = {1: "ä½ å¥½ï¼Œé™Œç”Ÿäºº", 2: "2026æ–°å¹´å¿«ä¹", 3: "AE Studio åˆ¶ä½œ"};
                    updateText(map[gid]);
                }
            }
        }

        // --- 4. åŠ¨ç”»æ¸²æŸ“ ---
        function animate() {
            requestAnimationFrame(animate);
            const posAttr = particlesMesh.geometry.attributes.position;
            const pos = posAttr.array;
            const ease = 0.12; // ç§»åŠ¨é€Ÿåº¦ç³»æ•°

            for (let i = 0; i < maxParticles; i++) {
                const i3 = i * 3;
                if (i < targetPositions.length) {
                    // ç›´æ¥å‘ç›®æ ‡ä½ç½®é æ‹¢ï¼Œæ²¡æœ‰ä»»ä½•æ‰©æ•£å¹²æ‰°
                    pos[i3] += (targetPositions[i].x - pos[i3]) * ease;
                    pos[i3+1] += (targetPositions[i].y - pos[i3+1]) * ease;
                    pos[i3+2] += (targetPositions[i].z - pos[i3+2]) * ease;
                } else {
                    // å¤šä½™ç²’å­æ²‰å…¥èƒŒæ™¯æ·±å¤„
                    pos[i3+2] += (-500 - pos[i3+2]) * 0.05;
                }
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 5. å¯åŠ¨ ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const video = document.getElementById('video-element');
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });

        initThree();
        cam.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
