<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>粒子交互</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { position: absolute; top: 10px; right: 10px; width: 180px; height: 135px; z-index: 2; transform: scaleX(-1); border: 1px solid #444; border-radius: 6px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; z-index: 10; }
        #ui-hint { position: absolute; bottom: 20px; left: 20px; color: #fff; z-index: 2; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 5px; border-left: 4px solid #fff; }
    </style>
</head>
<body>

    <div id="loading">模型加载中...</div>
    <div id="canvas-container"></div>
    <video id="video-element" playsinline></video>
    
    <div id="ui-hint">
        <div style="font-weight: bold; margin-bottom: 5px;">交互模式:</div>
        <div>通过手指让粒子做出相应指令(共3条)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        let scene, camera, renderer, particlesMesh;
        let targetPositions = [];
        const maxParticles = 8000;
        let currentText = "";
        let currentGesture = 1;

        // --- 1. Three.js 初始化 ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 130;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(maxParticles * 3);
            const colors = new Float32Array(maxParticles * 3);
            
            // 随机初始化位置
            for(let i=0; i<maxParticles * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 500;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);

            updateText("你好，陌生人");
            animate();
        }

        // --- 2. 文字采样逻辑 ---
        function updateText(text) {
            if (currentText === text) return;
            currentText = text;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; canvas.height = 200;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 800, 200);
            ctx.font = 'bold 80px "Microsoft YaHei"';
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 400, 100);

            const data = ctx.getImageData(0, 0, 800, 200).data;
            const newCoords = [];
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 800; x += 2) {
                    if (data[(y * 800 + x) * 4] > 128) {
                        newCoords.push({ x: (x - 400) * 0.45, y: -(y - 100) * 0.45, z: 0 });
                    }
                }
            }
            targetPositions = newCoords;

            // 统一颜色更新
            const colors = particlesMesh.geometry.attributes.color.array;
            const color = new THREE.Color(0x00ffff); // 设定为青色
            for(let i=0; i<maxParticles; i++) {
                const i3 = i * 3;
                if(i < targetPositions.length) {
                    colors[i3] = color.r; colors[i3+1] = color.g; colors[i3+2] = color.b;
                } else {
                    colors[i3] = 0; colors[i3+1] = 0; colors[i3+2] = 0;
                }
            }
            particlesMesh.geometry.attributes.color.needsUpdate = true;
        }

        // --- 3. 手势识别逻辑 (仅数字) ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // 指尖检测逻辑
                const isIndex = hand[8].y < hand[6].y;
                const isMiddle = hand[12].y < hand[10].y;
                const isRing = hand[16].y < hand[14].y;

                let gid = currentGesture;
                if (isIndex && isMiddle && isRing) gid = 3;
                else if (isIndex && isMiddle) gid = 2;
                else if (isIndex) gid = 1;

                if (gid !== currentGesture) {
                    currentGesture = gid;
                    const map = {1: "你好，陌生人", 2: "2026新年快乐", 3: "AE Studio 制作"};
                    updateText(map[gid]);
                }
            }
        }

        // --- 4. 动画渲染 ---
        function animate() {
            requestAnimationFrame(animate);
            const posAttr = particlesMesh.geometry.attributes.position;
            const pos = posAttr.array;
            const ease = 0.12; // 移动速度系数

            for (let i = 0; i < maxParticles; i++) {
                const i3 = i * 3;
                if (i < targetPositions.length) {
                    // 直接向目标位置靠拢，没有任何扩散干扰
                    pos[i3] += (targetPositions[i].x - pos[i3]) * ease;
                    pos[i3+1] += (targetPositions[i].y - pos[i3+1]) * ease;
                    pos[i3+2] += (targetPositions[i].z - pos[i3+2]) * ease;
                } else {
                    // 多余粒子沉入背景深处
                    pos[i3+2] += (-500 - pos[i3+2]) * 0.05;
                }
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 5. 启动 ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const video = document.getElementById('video-element');
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });

        initThree();
        cam.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>

